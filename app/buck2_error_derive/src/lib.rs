/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under both the MIT license found in the
 * LICENSE-MIT file in the root directory of this source tree and the Apache
 * License, Version 2.0 found in the LICENSE-APACHE file in the root directory
 * of this source tree.
 */

#![feature(proc_macro_def_site)]

use proc_macro::TokenStream;
use syn::parse_macro_input;
use syn::parse_quote;

/// Generates appropriate assignments to `category` and `typ` for the value in `val`.
///
/// Also, removes any attributes specific to this macro from the input.
fn generate_option_assignments(_input: &mut syn::DeriveInput) -> proc_macro2::TokenStream {
    proc_macro2::TokenStream::new()
}

fn derive_error_impl(input: TokenStream, krate: syn::Path) -> TokenStream {
    let def_site: proc_macro2::Span = proc_macro::Span::def_site().into();

    // For now, this is more or less just a stub that forwards to `thiserror`. It doesn't yet do
    // anything interesting.
    let mut input = parse_macro_input!(input as syn::DeriveInput);
    let option_assignments = generate_option_assignments(&mut input);
    let (impl_generics, type_generics, where_clauses) = input.generics.split_for_impl();

    // In order to make this macro work, we have to do a number of cursed things with reexports. As
    // a result, we need to be careful about not polluting the namespace in which the macro is
    // invoked. We achieve this by putting everything generated by the macro into a function. This
    // ident is the name of that function.
    let hidden_function_name = syn::Ident::new(
        &format!("__macro_generated_by_buck2_error_hidden_{}", input.ident),
        input.ident.span().resolved_at(def_site),
    );
    // Our goal is effectively to "hijack" the impls created by `thiserror::Error`. However, without
    // eager macro expansion this is not so easy to do. The strategy we opt for is to have two
    // types, an outer and an inner one. The outer type is the one that this derive macro is invoked
    // on. The inner one is a second type with the same definition - the `thiserror::Error` impl
    // will be applied to the inner type. The outer type will explicitly impl a number of traits,
    // often forwarding to the inner.
    //
    // Ideally we would implement this by using def site hygiene, instead of changing the name of
    // the type. However, that doesn't work because of a rustc bug with hygiened inheritance for
    // derive macros. See a previous attempt in 9b1d890e45dc.
    let outer = &input.ident;
    let mut input_for_inner = input.clone();
    input_for_inner.ident = syn::Ident::new(&format!("{}_", outer), outer.span());
    let inner = &input_for_inner.ident;

    // In order to forward from the outer type to the inner, we will need to transmute between them.
    // In the case of by-value conversions this would be avoidable, but in the case of reference
    // conversions it's not. The correctness of this relies on the assumption that type layout in
    // Rust is a function of the type definition only, ie that types with identical definition have
    // identical layout. This is true today, but is not guaranteed. If it ever changes, we will need
    // to start requiring `#[repr(C)]` or find a different way to implement this.
    let val_transmute = quote::quote! {
        ::core::mem::transmute::<#outer, #inner>
    };
    let lifetime = quote::quote! {
        'generated_lifetime_name
    };
    let ref_transmute = quote::quote! {
        ::core::mem::transmute::<&#lifetime #outer, &#lifetime #inner>
    };

    let derive_attribute = quote::quote! {
        #[derive(::core::fmt::Debug, thiserror::Error)]
    };
    quote::quote! {
        #[allow(unused)]
        #[doc(hidden)]
        #[allow(non_snake_case)]
        fn #hidden_function_name() {
            use #krate::__for_macro::thiserror;

            #derive_attribute
            #input_for_inner

            impl #impl_generics ::core::convert::From<#outer #type_generics> for #krate::Error
            #where_clauses
            {
                fn from(val: #outer #type_generics) -> Self {
                    #[allow(unused_mut)]
                    let mut typ = ::core::option::Option::None;
                    #[allow(unused_mut)]
                    let mut category = ::core::option::Option::None;
                    #option_assignments
                    let val: #inner = unsafe { #val_transmute(val) };
                    #krate::__for_macro::new_with_macro_options(val, typ, category)
                }
            }
            impl #impl_generics #krate::AnyError for #outer #type_generics
            #where_clauses {}
            impl #impl_generics #krate::__for_macro::Sealed for #outer #type_generics
            #where_clauses {}

            impl #impl_generics ::core::convert::From<#outer #type_generics>
            for #krate::__for_macro::anyhow::Error
            #where_clauses
            {
                fn from(val: #outer #type_generics) -> Self {
                    let val: #krate::Error = ::core::convert::From::from(val);
                    ::core::convert::Into::into(val)
                }
            }

            impl #impl_generics ::core::fmt::Display for #outer #type_generics #where_clauses
            {
                fn fmt<#lifetime>(&#lifetime self, f: &mut ::core::fmt::Formatter<'_>)
                -> ::core::fmt::Result {
                    let val = unsafe { #ref_transmute(self) };
                    ::core::fmt::Display::fmt(val, f)
                }
            }
        }
    }
    .into()
}

#[proc_macro_derive(ErrorForReexport, attributes(backtrace, error, from, source))]
pub fn derive_error_for_reexport(input: TokenStream) -> TokenStream {
    derive_error_impl(input, parse_quote! { ::buck2_error })
}

#[proc_macro_derive(Error, attributes(backtrace, error, from, source))]
pub fn derive_error(input: TokenStream) -> TokenStream {
    derive_error_impl(input, parse_quote! { crate })
}

// Implementation detail of `derive_error`
#[doc(hidden)]
#[proc_macro_attribute]
pub fn exterminate(_attr: TokenStream, _input: TokenStream) -> TokenStream {
    TokenStream::default()
}
